---
title: 'About rust ownership'
date: 2012-08-14
permalink: 
tags:
  - rust
---

只要搞清楚rust ownership的诉求，就能很好的理解它所采用的具体方案。

compiler的目标：**消除data racing**。在引用期间，保证不变性；在修改期间，保证单一性。（即RWLock的思路，多个reader或者单个writer）

为了实现这个目标（承诺），rust提供了两套机制。

## 1. inherited mutability

继承可变性是rust的默认实践。对于一个变量存在两类引用，`&`与`&mut` 。一个变量或者存在多个不可变引用，或者存在一个可变引用，前者保证在引用期间的不变性，后者保证修改期间无竞争写入。

**注** *rust在新版本中引入了NLL（非词法生命周期），放宽了在词法层面对**可变引用唯一**与**可变与不可变引用互斥**的检查，前提是compiler能在编译期分析出代码在逻辑上不会违反可变性的要求。*

## 2. interior mutability

继承可变性的设计是消除data racing的充分条件（非必要）：在`&`引用下，数据必然不可变，在唯一的`&mut`引用下，修改必然无竞争。

但在实际的业务代码中，该设计可能会不够灵活。变量作为参数或成员存在时，需要事先声明是可变引用还是不可变引用, 而在OOP代码中，不同对象可能会对同一数据存在不同可变性的引用，因而经常无法满足继承可变性对**可变引用唯一**或**可变与不可变引用互斥**的要求。

对于这种情况，有两种解决方案。一是采用data-oriented的风格，在编写业务代码前，以数据为中心，按照**可变引用唯一**与**可变与不可变引用互斥**的原则，设计好数据的ownership关系。

为了适应各类编程风格，增加语言的灵活性，rust也提供了第二种方案：内部可变性。主要通过`Cell`与`RefCell`实现。在数据外做一层包装，外层包装本身是不可变的，但提供了引用与修改内部数据的接口。此时compiler在编译期看到的变量永远是不可变的，因此确定不会panic，而`Cell/RefCell`则负责在**运行期**保证**有效可变引用唯一**或**有效可变与有效不可变引用互斥**。
