---
title: 'KMP子字符串匹配算法'
date: 2019-11-04
permalink: 
tags:
  - algorithm
  - KPM
---

这个算法因为它的名称，有点唬人的味道。实际上它的名称没有任何含义，仅是三名作者的名字首字母缩写。

而这个算法本身也没有深奥的设计，只是字符串匹配算法的一个优化技巧。网上介绍该算法的文章，往往晦涩难懂，还习惯配几张看似精妙的动图，令人费解。

判断子字符串（也称为pattern）是否与主串（也称为text）匹配，最自然的想法就是通过对主字符串进行逐位对照（常被称为BF=Brutal Force，暴力穷举)，直到子串完全匹配。

而KMP的方法也是如此，只是多了一个对子串中重复出现部分的优化。在一次匹配中，如果子串的当前字符和主串不匹配，即表示此次匹配失败，常规方法是，子串从头开始，从主串的下一个字符开始进行下一轮匹配。但假如我们的子串是这样一个字符串`abcde...abcde`, 我们很容易就发现这里有一个可以优化的地方，因为我们刚刚匹配过`abcde`，所以我们只需要从子串的第6个字符(`abcde`之后)开始比较就可以了。这就是KMP的全部思想。

在KMP的描述里，前面的`abcde`被称为前缀（prefix），尾部的`abcde`被称为后缀。而为了方便的计算出，具体要从子串的哪个字符开始下一轮匹配，KMP设计了一个简单的数据结构`PMT`(partial match table, 部分匹配表)。在这个表里，子串中的每个字符都对应一个值，这个值即是前面说的在本次匹配失效的时候，下次匹配的起始位置。而这个值的计算也特别简单：比如在子串前面的部分（`abcde...`）中没有**前后重复**的部分，所以它们的值都为0，因为不存在已经比较过的内容，所以下次匹配开始就要重新开始；而在在末尾的`abcde`中，在`a`的位置，存在相同的前缀`a`和后缀`a`，... 在e的位置，存在相同的前缀`abcde`和后缀`abcde`，所以这5个位置的值就取该重复部分的长度，依次为1、2、3、4、5。